[role="pagenumrestart"]
[[ch03_How_Lightning_Works]]
== How the Lightning Network Works

Now that we've followed Alice as she's set up a Lightning Wallet and purchased a coffee from Bob, we'll look under the hood and unpack the different components of the Lightning Network involved in that process.
This chapter will give a high level overview and will not delve into all the technical details.
The goal is rather to help you to become aware of the most important concepts and building blocks of the Lightning Network.

If you have experience in computer science, cryptography, Bitcoin, and protocol development, then this chapter should be enough for you to be able to fill out the connecting details by yourself.
If you are less experienced, this chapter shall give you a good enough overview so that you will have an easier time reading through the formal protocol specifications, known as BOLTs (Basis of Lightning Technology).
In case you are a beginner, this chapter will help you better understand the technical chapters of the book.
However, we are aware that some readers may have a hard time following high level descriptions without explaining all the details.
If you are one of those readers you may want to skip this chapter.

We'll start with a one sentence definition of what the Lightning Network (LN) is and break it down in the remainder of this chapter.

**The Lightning Network (LN) is both a peer-to-peer network of _payment channels_ on top of the _Bitcoin protocol_ as well as a communication protocol that defines how participants set up and execute the smart contracts on the Bitcoin network**

We will see that a payment channel is simply a 2-out-of-2 multisignature address on the Bitcoin network for which you hold one key and your channel partner holds the other key.
This multisignature address comes with a cryptographic protocol that is established by creating a sequence of transactions that spend from this address.
Each new transaction is negotiated between you and your channel partner and are attempts to spend from the multisignature address.
The latest transaction in the sequence encodes the balance of the channel and defines how the funds locked into the multisignature address are to be divided between you and your channel partner.
Thus adding a new transaction to this sequence is equivalent to moving ownership of funds in the channel, without the Bitcoin network being aware of it.
Each transaction in the sequence makes use of Bitcoin's scripting language, and thus the negotiation of funds between you and your channel partner is managed by a Bitcoin smart contract.
The contract is set up such as to penalize a channel member if it tries to steal funds by submitting an earlier invalidated state of the channel.

[NOTE]
====
When someone says they 'own' bitcoin they typically mean that they know the private key of a bitcoin address that has some unspent transaction outputs (UTXOs).
The private key allows the owner to produce a signature for a transaction that spends the bitcoin by sending it to a different address.
Thus 'ownership' of bitcoin can be defined as the ability to spend that bitcoin.

If you have an unpublished but signed transaction from a 2-out-of-2 multisignature address, where some outputs are sent to an address you own, and additionally you own one of the private keys of the multisignature address, then you effectively own the bitcoin of that output.
Without your help no other transaction from the 2-out-of-2 multisignature address can be produced.
However, without the help of anybody else you can transfer the funds to an address which you control.
On the Lightning Network ownership of your funds is almost always encoded with you having a pre-signed transaction spending from a 2-out-of-2 multisignature address.
====

Additionally, these contracts have the option to connect channels in a way that one can forward payments from one channel to another.
For example, Alice can send money to Bob if Alice had a channel with Mallory and Mallory had a channel with Bob.
By the design of the Lightning Network, it is possible to extend the smart contracts which operate the channel so that Mallory has no way of stealing the funds that are being routed through her.
Not only does the construction of the payment channel work for the partners without the necessity to trust each other but the entire network works without the necessity to trust any other participant.
Since the channels are funds on multisignature addresses and as the contracts are unpublished but presigned Bitcoin transactions, all the trust that is needed to operate the Lightning Network comes from the trust in the decentralized Bitcoin network!

The aforementioned innovations are certainly the major breakthrough that allow the creation of the Lightning Network.
However, the Lightning Network is so much more than the cryptographic protocols on top of the Bitcoin scripting language.
It is a full communication protocol that allows peers to communicate with each other via Lightning messages to achieve the transfer of bitcoin.
The communication protocol also defines how Lightning messages are being encrypted and exchanged.
A gossip protocol is part of the specification that is used to share public information about the topology of the network with the other participants.
This information is needed for Alice to be aware of the fact that Mallory has a channel with Bob so that she can decide to send a payment indirectly via Mallory to Bob.

Last but not least, it is important to understand that the Lightning Network is nothing but Bitcoin.
We emphasize this as you might find people who will try to spread misinformation and create a false barrier between the "real" Bitcoin and the Lightning Network or even use terms like the Lightning Network coin. At any point in time, any value held in the Lightning Network is exclusively held as bitcoin and exclusively secured by the Bitcoin network. 
We hope that as soon as you have studied the remainder of this book you do not need to believe what we just mentioned.
We rather hope that this book enables you to critically do your own research to understand and verify the following (instead of trusting us):
Besides all the technical primitives, the Lightning Network protocol is a creative way to get more benefits out of Bitcoin by allowing an arbitrary amount of instant payments with instant settlements without the necessity to trust anyone else but the Bitcoin network.

=== Payment channels

As you have seen in the last chapter, in order to use the Lightning Network, Alice had to use her wallet software to create a payment channel with another Lightning Network participant.
From a computer science perspective a payment channel is a cryptographic communication protocol between you and your channel partner.
It allows both of the channel partners to send funds back and forth as often as they wish.
A channel is only limited by two things:
First, the time it takes for the internet to transfer the few bytes of data that the protocol requires to make a payment between you and your partner.
Second, the capacity of the channel, which is the term for the monetary funds, i.e. bitcoin, that have been assigned to and locked up by the channel.
Payment channels have a couple of very interesting and useful properties.

* If the channel is open, making a payment does not require the confirmation of Bitcoin blocks. In fact - as long as you and your channel partner follow the protocol - it does not require any interaction with the Bitcoin network or anyone else other than with your channel partner.
* The cryptographic protocol is constructed in a way that there is little to no trust involved between you and your channel partner. If your partner becomes unresponsive or tries to cheat you, you can ask the Bitcoin network to act as a court system resolving the conflict according to the rules that you and your partner have previously agreed upon.
* The capacity of the channel will be split between you and your partner. In that sense at that level you already will have gained privacy compared to the Bitcoin network where every transaction is public. Within payment channels the amounts and values of payments are only known to you and your partner. Only the final balance which is the aggregate of all payments in that channel will become visible on the Bitcoin blockchain if and when the payment channel is closed.
* As the time to update the channel is primarily bound by the communication speed of the internet, making a payment on a payment channel is almost instant.

Bitcoin was about 5 years old when talented developers first figured out how payment channels could be constructed and by now there are at least 3 different methods known.
This chapter will only focus on the channel construction method proposed by Joseph Poon and Thaddeus Dryja in 2015 since it is actually being used in the Lightning Network and was first described in the Lightning Network whitepaper.
The two other proposed methods are the "Duplex Micropayment" channels which have been introduced by Christian Decker around the same time as the "Poon and Dryja" channels and the "eltoo" channels which have been introduced in 2018 by Christian Decker, Rusty Russel and our co-author Olaoluwa Osuntokun.
The later seem much easier to implement and have a couple of nicer properties.
However, these "eltoo" channels require a new OP_CODE in the Bitcoin scripting language and can therefore currently not be implemented on top of the Bitcoin mainnet.

==== Multisig addresses
Payment channels are smart contracts that build on top of 2-out-of-2 multisignature addresses which will be spent by Segwit transactions.
By knowing the properties of multisignature addresses you will be able to understand the exact construction of payment channels.
However, at this point we will not review all the technical details about multisignature addresses and Segwit but just stick to the basic properties.
If you know Bitcoin well enough to be familiar with those topics feel free to skip this section.

[TIP]
====
A deep dive into the topic discussed here is presented in chapter 7 of Mastering Bitcoin which can be found at: https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch07.asciidoc.
Also, in case you are not familiar with P2PKH addresses and the basic format and scripting language of Bitcoin we encourage you to study chapter 6 of Mastering Bitcoin which can be found at: https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc.
There is also a video on Rene's YouTube channel which dissects the bits and bytes of a transaction spending from a P2PKH output at: https://youtu.be/1n4g3eYX1UI
====

To allow escrow services and complex ownership configurations between several stakeholders, the Bitcoin scripting language provides multisignature addresses.
The general form of a locking script setting an M--out-of-N multisignature condition is:

----
M <Public Key 1> <Public Key 2> ... <Public Key N> N CHECKMULTISIG
----

where N is the total number of listed public keys and M is the threshold of required signatures to spend the output.

A special case which is particularly interesting for us is a locking script setting a 2-out-of-2 multisignature condition.
It would look like this:

----
2 <Public Key A> <Public Key B> 2 CHECKMULTISIG
----

The preceding locking script can be satisfied with an unlocking script containing pairs of signatures:

----
0 <Signature A> <Signature B>
----
The two scripts together would form the combined validation script:

----
0 <Signature A> <Signature B> 2 <Public Key A> <Public Key B> 2 CHECKMULTISIG
----

==== Funding Transaction
We have already seen that one of the important building blocks of a payment channel is a 2-out-of-2 multisignature address.
To open a payment channel one must send bitcoin to that address.
The Bitcoin transaction that sends bitcoin to that 2-out-of-2 multisignature address is called the funding transaction. 
It is included in the Bitcoin blockchain.
While the payment channel opened by two participants of the Lightning Network can be private, the funding transaction will always be publicly visible to the Bitcoin network.
The amount of bitcoin sent to the multisignature address forms an upper limit on how much Bitcoin can be transacted using the channel, and is called the capacity of the channel.
Two channel partners will never be able to conduct payments on a channel that are larger than its channel capacity.
While the Bitcoin network can see that funds have been committed to a channel using a funding transaction, it is unable to determine how those funds are distributed between the two channel partners.

[Note]
====
You might hear people falsely complaining about bitcoin being locked up by the Lightning Network preventing their movement.
This is incorrect.
One can use the Bitcoin network to send bitcoin from a P2PKH address as well as from a 2-out-of-2 multisignature address with a P2WSH transaction.
In both cases transfer of ownership incurs the corresponding bitcoin fees for processing the "on-chain" transaction on the Bitcoin network.
However, once the bitcoin are used to open a payment channel they can freely flow within the Lightning Network from one participant to another one.
If a channel partner should not respond, one will always have the chance to fall back to the on-chain transactions without the necessity for the channel partner to help to do so.
On-chain fees and Bitcoin confirmation times make moving bitcoin on the Bitcoin network more expensive and slower than moving bitcoin on the Lightning Network.
====

===== Example of a poor channel opening procedure
Alice wants to open a payment channel with Mallory but she is not yet fully aware of the Lightning Network Protocol.
She creates a new private and corresponding public key and talks to Mallory who does the same and sends her public key to Alice.
Now Alice prepares a Bitcoin Transaction sending a few mBTC to the multisignature address that was created from Alice's and Mallory's key.
As Alice wasn't aware of the protocol to open the channel she now has to trust that Mallory will provide her signature if Alice wants to spend from the multisignature address.
Mallory on the other side has the chance to execute a blackmail attack on Alice by holding back her signature and denying Alice access to her funds.

In order to prevent Mallory from performing such an attack Alice will need to create a spend transaction from the funding transaction and have that transaction signed by Mallory before she broadcasts her funding transaction to the Bitcoin network.
This transaction that protects Alice is called Commitment transaction and we will study it now.

==== Commitment Transaction

You have just learnt that a payment channel needs to be opened by preparing a funding transaction which sends the funds of the payment channel to a 2-out-of-2 multisignature address.
From the example in the last section you learnt that more ingredients are necessary to open and operate a payment channel that does not rely on trusting the channel partner.
These ingredients are the commitment transactions.
They are used to make sure that everyone connected to a channel is able to get its own funds back in case the channel partner becomes unresponsive or, even worse, if the channel partner deliberately or by accident tries to cheat during the execution of the protocol.
The commitment transactions also encode the balance of the payment channel.
The balance of the payment channel is an agreement by the channel partners about how the funds, i.e. capacity, are split among the partners.
Let us assume Alice opens a channel with a capacity of 10 mBTC with Bob.
Naturally, initially Alice should still be in the possession of the 10 mBTC.
This can actually be easily achieved with the following construction:

. Alice creates a new private / public key pair and informs Bob that she wishes to open a channel via the `open_channel` message.
. Bob also creates a new private / public key pair and agrees to accept a channel from Alice while sending his public key to Alice via the `accept_channel` message.
. Alice now creates a funding transaction from her wallet that sends 10 mBTC to the multisignature address with a locking script `2 <Public Key A> <Public Key B> 2 CHECKMULTISIG`.
. Alice does not broadcast the funding transaction but informs Bob about the transaction id of the funding transaction by sending a `funding_created` message.
. Both Alice and Bob create their version of a commitment transaction. This transaction will spend from the funding transaction and send all the bitcoin back to an address controlled by Alice.
. Alice provides a signature for Bob's Commitment Transaction. This signature was already included in the `funding_created` message.
. Bob provides a signature for Alice's Commitment Transaction and sends this back to Alice via the `funding_signed` message.
. Only after signatures have been exchanged Alice will broadcast the funding transaction to the Bitcoin network.

By following this protocol Alice did not give up ownership of her 10 mBTC even though the funds have been sent to a 2-out-of-2 multisignature address for which Alice controls only one key.
If Bob stops responding to Alice she will be able to broadcast her commitment transaction and receive her funds back.
She will only have lost the fees for the two on-chain transactions.
As long as she follows the protocol and has her node secured this is her only risk when opening a channel.

At channel opening time, the commitment transactions serve the purpose of allowing Alice to withdraw her funds directly after opening the channel in case Bob does not answer. However, commitment transactions are created each time the channel balance changes. In other words, each time bitcoin is sent between Alice and Bob new commitment transactions are created. Each commitment transaction encodes the latest balance between Alice and Bob.
If Alice wanted to send 3 mBTC to Bob to pay him for a service he offered, both would create a new version of their commitment transactions which would now send 7mBTC to Alice and 3 mBTC to Bob and share signatures with each other.
However, there is still a piece missing in the design presented so far.

**Do you see any way how Alice could cheat on Bob?**

How many commitment transactions does Alice hold after her payment of 3mBTC to Bob? She holds two, the original one giving her 10 mBTC and the last one giving her 7mBTC. As you see, in the design presented so far nothing could stop Alice from publishing an old or even initial commitment transaction. A crooked Alice could publish the commitment transaction which grants her 10 mBTC.
Since that commitment transaction has previously been signed by Bob he can't prevent Alice from doing so.
A smarter mechanism is needed to prevent Alice from publishing an old commitment transaction. 
Let us now find out how this can be achieved and how an improved mechanism enables the Lightning Network to operate without trust.
As Bitcoin is censorship resistant no one can prevent a participant from the Lightning Network to publish an old commitment transaction.
Imagine, the commitment transactions can be slightly modified so that publishing an outdated commitment transaction can be punished. 
A high punishment will discourage cheating.
The penalty for broadcasting an old commitment transaction is to give the cheated channel partner the ability to claim the funds that belonged to the cheater, i.e. the broadcaster of the outdated transaction.
With this modification in place, let us go through this scenario again. 
Alice creates a channel with Bob and put 10 mBTC into it. 
Alice send 3 mBTC to Bob. 
Alice now tries to cheat Bob out of his earned 3 mBTC by publishing an old commitment transaction claiming the original 10 mBTC for herself. 
With the modification, Bob can now detect the fraud and he is enabled to punish Alice for the fraud by claiming the full 10 mBTC for himself. 
Bob ends up with 10 mBTC gaining 7 mBTC for catching Alice cheat. 
Alice ends up with 0 mBTC. 
For cheating she lost the 7 mBTC she still had. 
With such a strong penalty mechanism in place Alice will not be tempted to cheat by publishing an old state as she would almost always lose all her remaining funds in the channel.

[Note]
====
In Mastering Bitcoin Andreas states it very elegantly:
A key characteristic of bitcoin is that once a transaction is valid, it remains valid and does not expire. The only way to cancel a transaction is by double-spending its inputs with another transaction before it was mined. That's why we used timelocks [...] to ensure that more recent commitments could be spent before older commitments were valid.
====

We will now see how such a penalty mechanism can be included to the above construction of the commitment transactions.
Usually the commitment transaction has at least two outputs, one for each partner.
As new addition, a channel partner will encumber their own output with a timelock and a revocation secret.
The timelock prevents the owner of the output to spend it immediately once the commitment transaction was included in a block.
The timelock is usually measured in blocktime and can be up to 2016.
On average, 2016 blocks represent or last two weeks (assuming a blocktime of 10 minutes as in the Bitcoin network).
Be aware, the exact number of blocks used for the timeout can be set to different values by different software.
2016 is just the maximum value, but smaller values are possible.
footnote:[Users likely prefer a longer timeout value for a larger channel capacity.]
Within the timelock anyone who knows the revocation secret can spend the output even before the timelock is over.
Alice and Bob know only one half each of the revocation secret.
But if they share their half with the other channel partner, then the other partner knows the full secret.
In order to update the balance and receive a signature from Bob, Alice will have to share her half of the revocation secret of the current commitment transaction with Bob.

Obviously, for every new update of the channel balance new revocation secrets have to be created and saved. 
As long as a channel remains open, all revocation secrets ever created for this specific channel need to be kept as they might be needed in the future.
Luckily, the secrets are rather small and it is only the channel partners who need to keep them, not the entire network.
Nevertheless, managing and storing the revocation secrets is one of the more elaborate parts of Lightning nodes that require node operators to maintain backups.
Other technologies such as Watchtower services or switching to the aforementioned "eltoo" channels might be future strategies to mitigate these issues.

With the timelocks in place Alice can close the channel at any time if Bob does not respond, claiming her fair share of the balance.
After publishing the commitment transaction "on-chain" Alice has to wait for the time lock to expire before she can spend her funds from the commitment transaction.
Other than that and the "on-chain" fees for opening and closing a channel there comes no additional burden with maintaining a payment channel.

==== Announcing the channel
Channel partners can agree to publicly announce the channel to the rest of the Lightning Network using the gossip protocol.
This is called a "public" channel.
A channel that is not publicly announced to the rest of the network is called a "private" channel.
With a private channel, only the channel partners are aware of it.
Note that even for private channels, the funding transaction is publicly stored in the Bitcoin blockchain, although it may not be obvious to those on the Bitcoin network that this transaction is, in fact, a funding transaction.

Announcing channels is useful to other Lightning Network participants as nodes can use existing channels to route payments.
Private channels can only be used to route payments by the channel partners themselves, and other nodes that they have chosen to make aware of the channel.
In this way, private channel networks can exist within the public Lightning Network.
When a channel is publicly announced using the gossip protocol, the channel partners also announce its channel capacity and some meta data about the channel.
This meta data can include the routing fees the channel partner will charge other users to route payments through that channel, as well information about the Hash Time-Locked Contracts (HTLCs) that will be accepted.
HTLCs are additional conditional outputs in the commitment transactions used for routing payments and updating channel balances, and will be discussed later in the book.

When a new participant joins the Lightning Network they will be able to collect information about other channels propagated via the gossip protocol from their peers.
This will allow a new participant to form a topological map of the channels (and their capacity) on the Lightning Network.
Note that peers can only omit messages about other channels.
They cannot falsify messages about other channels as every message is cryptographically signed by the node that created that message.

==== Closing the channel
The goal of people using the Lightning Network is to keep their channels open as long as possible.
Opening and closing payment channels costs time and money as on-chain Bitcoin transactions need to be made, and these transactions require fees and users need to wait for them to be confirmed.
Hence, creating and closing a Lightning channel for a single payment is inefficient; the payer could have used a single Bitcoin transaction to pay the recipient rather than incur one transaction to open the channel and another to close it.
The longer a channel remains open, and the more payments are made on it, the more efficient it will become in terms of fees and on-chain storage.
An open channel allows you to make as many payments as you wish on the Lightning Network, as long as the channel has funds and a route to payment the payment exists.
As long as the payments routed through that channel do not result in all of the capacity ending up on one side of the channel (i.e. payments move back and forth), then an open channel could theoretically accommodate an infinite number of payments and may never need to be closed.
However, closing a channel is sometimes desirable or necessary. For example:

* Your Lightning Node has become compromised and you wish to secure your funds by closing the channels and sending the Bitcoin to cold storage.
* Your channel partner is offline too frequently, preventing you from using the funds in that channel.
* After analyzing your routing statistics and the network topology, you conclude that it would be better to close underutilized channels and use those funds to open channels with better connected peers.
* Your channel partner might have breached the protocol either due to a software bug or via an attempted theft, forcing you to protect your funds.

There are 3 ways to close a payment channel:

* Mutual Close (the good way)
* Force Close (the bad way)
* Protocol Breach (the ugly way)

Each of these methods is useful for different situations which we will explore in the rest of the chapter.
The Lightning Network client used will usually select the appropriate channel closing method given the situation, regardless of whether it was the user or the node software that initiated the channel close.

===== Examining a Mutual Close (the good way)
Mutual Close is when both channel partners agree to the closure of a channel and is the preferred method of channel close.
One user will initiate a channel close by signaling to their channel partner that they wish to close the channel.
When the channel partner receives the message and agrees to a close, both partners will prepare the channel to be shut down.
No new routing attempts will be accepted from either channel partner and any ongoing routing attempts will be settled or removed after they have timed out.
As finalizing the routing attempts can take some time, a Mutual Close can also take some time.
Once no further routing attempts are pending, the closing transaction is prepared.
The closing transaction is similar to commitment transaction; it encodes the last balance of the channel but the outputs are NOT encumbered with a time lock.
The on-chain transaction fees of the closing transaction are paid by the channel partner who opened the channel and not by the partner who initiated the close.
As both channel partners sign the on-chain transaction they have the chance to pay low fees for the Bitcoin transaction using on-chain fee estimator.
Once the closing transaction is submitted to the Bitcoin blockchain, the channel partners wait for the transaction to be confirmed, and finally the channel is closed.
Despite the waiting time, this channel close is typically faster than a Force Close.

===== Examining a Force Close (the bad way)
A Force Close is when one channel partner attempts to close a channel without the other channel partner's consent.
This is usually in the case that one of the channel partners is unreachable, and so a Mutual Close is not possible.
A Force Close is initiated by publishing the latest commitment transaction your node has.
As discussed before, the Bitcoin network has no way of knowing if this was the most recent commitment transaction or an old one which you might have published to steal from your channel partner.
As previously discussed, commitment transactions are encumbered with a timelock to prevent this.
After the commitment transaction is confirmed, you will have to wait for the timelock to expire before the channel funds can be spent.
The funds of your channel partner are not encumbered with a time lock and can be spent immediately.
The on-chain fees will be higher than a Mutual Close for several reasons:

* At the time the commitment transaction was negotiated, you and your channel partner did not know what the future on-chain fee would be at the time of close, so a high fee is likely to have been selected.
This is because fees cannot be changed after a transaction is signed, so a high fee is safer as it gives a better guarantee that the commitment transaction will be confirmed when it is needed.
* Any pending routing attempts in the commitment transaction are encoded as additional outputs which take up additional on-chain transaction space. They will have to be resolved as additional on-chain transactions.

In general, Force Close should not be used unless absolutely necessary.
Higher on-chain fees than necessary will be paid and the funds will be unusable until the timelock expires.
Furthermore, you might have to pay on-chain fees to abort or settle routing attempts.

If your channel partner is known to you and their node is currently unreachable, it might better to contact that person directly and request that they restart or fix their Lightning Node.
Once their node has become reachable again, a Mutual Close can be initiated.

===== Examining a Protocol Breach (the ugly way)
A Protocol Breach results when your channel partner tries to cheat you, whether deliberately or not, by publishing an outdated commitment transaction to the Bitcoin blockchain, essentially initiating a Force Close from their side.
As discussed above, their outputs are encumbered by a timelock.
You have until this timelock expires to detect this attempt to cheat and enforce a penalty.
If you successfully detect the Protocol Breach and enforce the penalty, you will receive all of the funds in channel, including your channel partner's funds.
If you fail to detect the Protocol Breach and the timelock expires, you will receive only the funds allocated to you by the commitment transaction; any funds you received after this will have been stolen.

Note that when you detect a Protocol Breach and use the revocation secret to enforce a penalty, you will have to pay high on-chain fees in order to have the penatly transaction confirmed _before_ the timelock expires.
However, as you will eventually receive all of the cheater's funds, it is essentially the cheater who will be paying for this transaction.
Note also that if the Protocol Breach is not detected and the timelock expires, the fee for the commitment transaction are paid by the partner who opened the channel, and the fees for collecting the outputs are paid by the final owner of those outputs.

As with a Force Close, all pending routing attempts will also have to be resolved and paid for.
A Protocol Breach can be executed faster than a Mutual Close, as you do not need to agree to a close with your partner or wait for routing attempts to resolve, and faster than a Force Close as you do not need to wait for the timelock to expire.

Game theory predicts that cheating is not an appealing strategy because it is easy to detect a cheater, and the cheater risks losing _all_ of their funds while only standing to gain what they had in an earlier state.
Furthermore, as the Lightning Network matures, and Watchtowers become available, cheaters will be able to be detected by a third party even if the cheated channel partner is offline.
Hence, we do not recommend cheating.
We do, however, recommend that anyone catching a cheater punish their to the fullest by taking their funds.

We briefly discuss here how to detect a Protocol Breach and catch a cheating attempt against you.
The typical way is to monitor the Bitcoin blockchain for any commitment transactions that reflect an outdated state of your channel.
This can be done with a Bitcoin node, or Lightning Node software that is able to monitor the Bitcoin blockchain.
Specific Lightning wallets might also be capable of this.
However in all of these cases, you will have to be online 24/7 to detect an attempted cheat.
Note that the commitment transaction has a timelock period specified in a given number of blocks, up to a maximum of 2016; hence you have only until then to detect the cheater.

For example, assume that your commitment transactions have been set to the maximum timeout of 2016 blocks, roughly corresponding to two weeks.
In this case, if you run your Lightning node only once every Sunday, it will still catch all cheats.
However if you run your node less frequently than this, say once a month, then you could be cheated in a two-week interval wherein your node is offline.
footnote:[Even if the timeout is set to 2016 blocks, this may eventually be less than two weeks. If the Bitcoin blockchain difficulty is low, blocks will be mined faster and the target block specified in the timelock will be reached in less than two weeks. It is the block number that counts, not the time that has passed. So, in our example the user is prudent and checks every Sunday, and not every two weeks. This gives them a safety margin. ]
In the future it will become possible for a third-party to detect an attempted cheat against you and publish the revocation secret on your behalf.
One of these technologies is called a "Watchtower".

This risk of cheating presents attack vectors on the Lightning Network that are not present in Bitcoin.
Imagine a hypothetical situation where you go on a 3-week sailing trip.
Before you leave you turn off your Lightning node to save power and you turn your cell phone off because there is no cell coverage.
Now add to that that you have not requested a third party, such as a wallet provider or a Watchtower, to monitor your channels.
If your channel partner cheats you during the first two days of your remote vacation, they will be able to steal your funds and wait for the two-week timelock to expire and you will only discover this when you return from your vacation.
It is for this reason that future technologies like "Watchtowers" will become necessary to maintain security on the Lightning Network.

=== Invoices

Every payment on the Lightning Network begins with a person who wants to receive bitcoin issuing an invoice.
An invoice is an instruction requesting a payment that contains information such as: a unique payment identifier called a payment hash, a recipient, an amount requested, etc.
The reason for this structure is because it makes a payment on the Lightning Network "atomic".
This means that paying an invoice is an indivisible building block of the Lightning Network.
There is no such a thing as a partial payment; an invoice is either paid in full or it is not paid.
No node who routes the payment can take a portion of the money or decide not to transmit the payment once they have received it.
A payment is either transferred successfully through the complete path of nodes or it fails and is not delivered at all.

While Lightning nodes usually use encrypted communication channels over the Lightning Network to exchange information, invoices are transferred via a second communication channel.
The invoicer (i.e. the recipient) can pass the invoice to the payer (i.e. the sender) via any arbitrary means, such as a website, e-mail, SMS, social media networks, or a chat app.
Invoices are typically encoded as either a bech32-encoded string or a QR codes which can be easily scanned by a smartphone camera.
An invoice will contains the amount of bitcoin that is requested and a signature of the invoicer.
The latter is used to extract the address of the invoicer so that the payer knows to whom to send the money.
Invoices contain other meta data, the most important of which is the Payment Hash, a unique ID assigned to this invoice.
Furthermore invoices can be specified with a time limit e.g. 10 minutes.
Once this time limit has expired, the invoice can no longer be paid.

[[sample-invoice]]
.This is a sample invoice. Please in both QR Code and bech32-encoded format. This invoice cannot be paid as it has expired.
image:images/eclair-playstore.png["Sample Invoice from Satoshi's Place"]

Note that the terminology of Lightning Invoices contrasts with that of Bitcoin payments.
In Bitcoin, the recipient passes an address to the sender.
In Lightning, the recipient creates an invoice and sends it to the payer with an amount already specified.
In Bitcoin, the payer sends funds to an address via a transaction that is confirmed on the Bitcoin blockchain.
In Lightning, the payer pays an invoice, and the funds are routed to the recipient.
A bitcoin "transaction" paid to an "address" is thus analogous to a Lightning "payment" that fulfills an "invoice".

==== Payment Hash
The recipient will choose a random number `r` and produce the `sha256` hash of that number which we call the Payment Hash `H(r)`.
Note that an adversary should have no means of guessing or predicting `r`.
Using a customer id or the hash of entries of the shopping cart together with a timestamp is not truly random and yields a security risk.
The payment process of the Lightning Network is only secure if `r` is chosen completely randomly and is not predictable and as long as the Hash function cannot be inverted.
We note that this is not an additional security assumption for Bitcoin as the security of the Hash function is currently the underlying basis of Bitcoin mining.

==== Additional Meta Data
Invoices can encode some other useful meta data, for example a short description.
This is helpful to a user who has several invoices to pay; they can read the description and be reminded what the invoice is about.
As payment channels do not need to be publicly announced, the recipient can also provide some private channels as routing hints to the invoice.
These hints can furthermore be used to suggest public channels, e.g. those channels on which the recipient has enough inbound liquidity to actually receive the amount.
In case the payer's Lightning node is not able to send the payment over the Lightning Network, invoices can optionally include an on-chain Bitcoin fallback address.
We would however always recommend to open a new Lightning payment channel instead of doing an on-chain Bitcoin payment.
Invoices also have an expiry time so that the recipient can delete the preimage after some time to free up space.

=== Delivering the payment

We have already learnt that payments start with the recipient creating an invoice which includes a Payment Hash.
In this section we will explore the methods used to deliver a payment over the Lightning Network and utilize everything that we have presented so far.
We first need to introduce one missing protocol of the Lightning Network which is the gossip protocol.

==== The peer-to-peer gossip protocol

As mentioned payment channels can be announced to the network after they are established.
This happens via a peer-to-peer gossip protocol.
After opening a channel a node will send out an announcement of the channel via the `channel_announcement` message to its peers.
Every peer can validate the information from the `channel_announcement` message and verify that the funding transaction was indeed confirmed by the Bitcoin network.
Upon verification the node will forward the gossip message to its peers.
In order to avoid spam this will only be done if the message was not forwarded by that node already.
Similarly nodes can be announced via the gossip protocol with the `node_announcement` message.
For this message to be forwarded a node has to have at least one public channel that was announced on the gossip protocol.
This again is a spam reduction measure of the gossip protocol.

Payment channels have various meta data that are useful for other participants of the network.
This meta data is mainly used for making routing decisions.
As nodes might want to change the meta data of their channel occasionally this information is shared in a `channel_update` message.
These messages will only be forwarded about four times a day for every channel to prevent spam.
The gossip protocol also comes with a variety of queries and tools to initially synchronize a node with the view of the network or to update the node's view after being offline for a while.
We will investigate the details of the gossip protocol in a later chapter.
For now it is only important to know that it exists and that it is used to share topology information of the Lightning Network with its participants.
This topology information is crucially needed for delivering payments through the network of payment channels.

[NOTE]
====
A major challenge for the participants of the Lightning Network is that the topology information that is being shared by the gossip protocol is only partial.
For example, the capacity of the payment channels is shared on the gossip protocol via the `channel_announcement` message.
However, this information is not as useful as the actual distribution of the capacity into the local balance between the two channel partners.
A node can only forward the amount of bitcoin via a particular payment channel that it actually owns within that channel.
While Lightning could have been designed to share balance information of channels and a precise topology, this has not been done for several reasons:
1. To protect the privacy of the users and not shout out every financial transaction and payment that is being conducted.
2. To be able to scale the amount of payments that can be conducted with the Lightning Network. Remember that the Lightning Network was created in the first place because notifying every participant about every payment does not scale well.
3. The Lightning Network is a dynamic organism and its topology changes constantly and frequently. Nodes are added, other nodes are turned off, channels are opened and closed, balances change, etc. Even if everything is always communicated, the information will be valid only for a short amount of time. Information might become outdated by the time it is received.
====

==== Finding a path

Payments on the Lightning Network are forwarded along a path of channels from one participant to another.
Thus, a path of payment channels has to be selected.
If we knew the exact channel balances of every channel we could easily compute a payment path using any of the standard path finding algorithms taught in any computer science program.
This could even be done in a way to minimize the fees paid to the intermediary nodes to route the payment.
However, the balance information of channels is constantly changing and cannot be available to all participants of the network.
Thus, we need to have one or more innovative path finding strategies.
These strategies must relate closely to the routing algorithm that is used.

As we will see in the next section, the Lightning Network uses a source-based onion routing protocol for routing payments.
This means that the sender of the payment (i.e. the "source" of the payment) has to find a path through the network.
With only partial information about the network topology this is a real challenge and active research is still being conducted into optimizing route-finding on the Lightning Network.
The fact that the path finding problem is not fully solved on the Lightning Network is a major point of criticism towards the technology.
The path finding strategy currently implemented in Lightning nodes is to probe paths until one is found that has sufficient liquidity to forward the payment.
While this strategy is not optimal and can be improved, it should be noted that even this simplistic strategy works for the vast majority of payments.
This probing is done by the Lightning node or wallet and is not directly seen by the user of the software.
The user might only realize that probing is taking place if the payment does not go through instantly.
This algorithm currently also does not necessarily result in the path with the lowest fees.

[NOTE]
====
On the Internet we use the internet protocol and the IP forwarding algorithm to forward internet packages from the sender to the destination.
While the TCP/IP protocol stack allows reliable communication by resending packages that are not acknowledged. this mechanism can't be reused directly in the Lightning Network.
A payment that is not forwarded would effectively mean that the money was stolen by an intermediary router and the sender cannot simply send another payment.

The routing protocol together with the Border Gateway Protocol used for data transport on the internet have the useful property of allowing the internet hosts to collaboratively find a path for the information flow through the internet.
However, we cannot adopt this protocol for forwarding payments on the Lightning Network.
====

Of course, path finding is trivial if we want to pay our direct channel partner and we have enough balance on our side of the channel to do so.
In all other cases information from the gossip protocol is used to help with path finding.
This includes currently known public payment channels, known nodes, known topology (how known nodes are connected), known channel capacities, and known fee policies set by the node owners.

==== Onion routing

If the node sending a payment has selected a path to route that payment, the Lightning Network uses an onion routing scheme similar to the TOR-network.
The routing scheme is called the "SPHINX mixformat" and will be explained in detail in a later chapter.
Note that onion routing via "SPHINX mixformat" is only similar to TOR network routing in concept.
As a protocol and in its implementation, Lightning Network onion routing differs from the TOR network.

For now we will focus on the properties of Lightning Network onion routing for the transport of payments.
A payment package used for routing is called an "onion".
footnote:[The term "onion" was originally used by the TOR project.
The acronym TOR stands for "The Onion Router".
Moreover, the Tor network is also called the Onion network.
This is not to be confused with the Onion News Network
The Tor project uses an onion as its logo and the top level domain name used by TOR services on the internet is ".onion".]
As a simplified physical analogy imagine the payment package as a sealed box with a onion inside.
On its route from payer to recipient the sealed box is handed from node to node.
Sealed in this case means that the box is encrypted and only the receiving node can open it.
As will be explained, each node opens the box, takes out the onion, and peals off the outermost layer of this onion using a cryptographic key.
The receiving node can only read this outermost layer, and no further layers.
This is achieved through cryptography.
This outermost layer tells the node if the box needs to be routed further and along which channel which also implies which node to contact next.
The node than places the remaining onion, but one layer smaller, into the box and sends the box to the next node on the routing path.
This continues until the receiving node is the recipient and the routing stops.
The recipient can then read the information encrypted in the innermost layer of the onion.
Why use a box?
The box is used in this analogy to express that the size of the "package" sent along the route is always the same.
The first routing node receives a box of the same size as the last node i.e. the recipient.
This is done to achieve privacy.
If not done, an observer could analyze the size of the communication and deduce how many hops there are on the route.
If the size does not change there is no way to tell if this is the first or the last hop in the route.
The box in our analogy is what technically is called an "onion" in the Lightning network.

Some notes about routing payments:

1. The most important property is that a routing node can only see on which channel it received an onion and on which channel to forward the onion.
This means that no routing node can know who initiated the payment and to whom the payment is destined.
The exception is the recipient, who knows that it is the final destination.
This is one of the many factors that helps in the quest for maintaining the privacy of Lightning Network participants.
2. The onions are small enough to fit into a single TCP/IP package and actually even a link layer frame.
This will make traffic analysis of the payments significantly more difficult, increasing privacy further.
3. The onions are constructed in a way that they will always have the same length independent of the position of the processing node along the path.
This is also done to improve privacy.
4. Onions can have up to 20 hops or onion layers if you prefer. This allows for sufficiently long paths.
5. The encryption of the onion for every hop uses different ephemeral encryption keys with every single onion. Should a key leak at some point in time an attacker who collected onions cannot decrypt other onions.
In simpler terms, keys are never reused in order to achieve more security.
6. Errors can be sent back from the erring node in an encrypted way to the original sender.
This is particularly useful as we have seen that Lightning nodes who initiate the onions select a path without knowing whether every node has enough liquidity along their channels to forward the payment.

We will discuss the details of the Onion Format later.
For now we note that the `Payment Hash` which is required to set up the HTLCs for the payment is not transported within the onions.
The `Payment Hash` is instead included in the Lightning Message alongside the onion.
This makes the Payment Hash obtainable without the need to decrypt any onion.

==== Payment Forwarding Algorithm

In contrast to the Internet Protocol Forwarding Algorithm, on the Lightning Network it is only the sender of a payment that decides the path the payment takes to the recipient.
Forwarding nodes can only reject a path; they cannot alter a path.
This can happen either on purpose or because they are not able to fulfill the request.
The payment forwarding algorithm is initiated by the sender of a payment who selects a path through the Lightning Network and constructs an onion.
It contains information about the payment for the recipient and routing hints for the intermediary nodes.
The onion also includes information about routing fees which will be paid to routing nodes if (and only if) the payment is successfully delivered.

All Lightning Nodes must follow the payment forwarding algorithm.
Upon receiving a Lightning Message called `update_add_htlc`, which contains the `Payment Hash` and the onion package, it needs to follow through X steps:

1. It needs to decrypt the outer layer of the onion and use the HMAC to make sure that the onion was not corrupted.
2. It will check that it can fulfill the routing hints in the way that its routing fees are in accord with its fee announcements, and that it has enough liquidity on the outgoing channel (or is even owner of the specified channel).
3. It needs to work with its peer on the incoming channel to update the channel state to include the offered HTLC.
4. It will have to add some padding data to the end of the onion to keep it a constant size even though it removed some data from the onion in Step 1.
5. It will then follow the routing hints from its layer of the onion to forward the modified onion package on its outgoing payment channel by also sending an `update_add_htlc` message which includes the same `Payment Hash` and the onion.
6. Finally it has to collaborate with its peer on the outgoing channel to move forward the state to also include the offered `HTLC`.

If an error is detected at any point, the steps will be interrupted ad the payment will be aborted.
In most of those cases an error message will be send back to the originator of the received `update_add_htlc` message.
If for example, in the Step 1 the node detects that the onion was corrupted it will not proceed to the second and subsequent steps to move forward the channel state on the receiving channel to include the HTLC.
Similarly if in the second step the node discovers that it won't be able to fulfill the routing request or that not enough fees have been included it will also abort the payment forwarding algorithm and send back an error.

We note that the error is also an onion reply package.
Even though the node sending the error does not know who initially sent out the payment the error message will be encrypted with the key that was used to encrypt the forwarding nodes layer.
The reply onion is then sent back on the incoming channel.
The node on the other side knows on which channel it received an onion and with which other channel it has an HTLC with the same `Payment Hash`.
Thus the error can safely propagate back along the payment path towards the originator.
Nodes that are sending back an error Onion must also remove the HTLCs from their payment channels to make sure that they cannot be enforced.
This, in essence, reverts the state of these nodes back to how it was before they attempted to route the payment.

[NOTE]
====
It is important to understand that HTLCs have a time measured in absolute blockheight through which they are valid.
Once the sender of a payment sends away the onion it is completely out if their control what happens.
Honest nodes should either forward the onion as quickly as possible or send an error back the original.
While the sender expects nodes along the path to be honest, it has no power of making sure that nodes act quickly.

Thus payments can get stuck if routing nodes behave maliciously.
While the likelihood for a payment to fail is high if it does not settle quickly, a node should never initiate another payment attempt along a different path before the onion returns with an error.
This is because the payment might not have failed, but simply have been delayed by one of the routing nodes.
Nodes which act maliciously by delaying the forwarding of payments or errors are hard to detect due to the privacy properties that are gained with the onion routing scheme.
This is further problem in the current implementation of the Lightning Network that will have to be adressed for a smooth user experience.
====

=== Missing bits
From a computer science perspective the Lightning Network protocol is mainly a peer to peer protocol between its participants.
All communication between participants is sent via so called Lightning Messages.
Most importantly communication is needed to open and close payment channels, to send and receive onions, to set up and settle or fail HTLCs and for exchanging gossip information.
The Lightning messages are sent in an encrypted way after a peer connection has been established.
Establishing the peer connection follows a cryptographic handshake following the Noise Protocol Framework.
The Noise Protocol Framework is a collection of templates for cryptographic handshakes and is also used by WhatsApp and Wireguard.
Using the Noise Protocol Framework makes sure that every message that is sent via Lightning is encrypted and authenticated.
This makes development a little bit tricky as one cannot easily monitor one's own traffic on a tool like wireshark for debugging. footnote:[Luckily tools exist to make developer's lives easier: https://github.com/nayutaco/lightning-dissector]

=== some thoughts that were supposed to be at other places but didn't make it to the text yet
* network of payment channels
* different scope of the network
** global path finding (entire knowledge of the network necessary)
** multihop routing (onion necessary only a subset of nodes involved)
** locally setting up and settling HTLCs (only peers involved)

=== Thoughts about Trust
As long as a person follows the protocol and has their node secured, there is no major risk of losing funds when participating in the Lightning Network.
However, there is the cost of paying on-chain fees when opening a channel.
Any cost should come with a corresponding benefit.
In our case the reward for Alice for bearing the cost of opening a channel is that Alice can send and receive payments of bitcoin on the Lightning Network at any time and that she can earn fees in bitcoin by forwarding payments for other people.
Alice knows that in theory Bob can close the channel immediately after opening resulting in on-chain closing fees for Alice. 
Alice will need to have a small amount of trust in Bob. 
Alice has been to Bob's Cafe and clearly Bob is interested in selling her coffee, so Alice can trust Bob in this sense. 
There are mutual benefits to both Alice and Bob.
Alice decides that the reward is enough for her to take on the cost of the on-chain fee for creating a channel to Bob. 
In contrast, Alice will not open a channel to someone unknown in a foreign country who just sent her an uninvitedly email asking her to open a channel to him. 

=== Comparison with Bitcoin

While the Lightning Network is built on top of Bitcoin and inherits many of its features and properties, there are important differences that users of both networks need to be aware of.

==== Addresses vs Invoices, Transactions vs Payments

Bitcoin and Lightning have different terminology.
In Bitcoin, a typical operation is that a user receives a Bitcoin address (e.g. he reads it on a webpage, or he received it in an instant message from a friend).
He then uses his Bitcoin wallet to create a transaction to send funds to this address. 

In the Lightning Network all starts at the payee. 
The payee creates an invoice. 
A Lightning "invoice" could be seen as an analogy to a Bitcoin "address".
The payee provides the Lightning invoice to the payer. 
This is similar to Bitcoin, the payee places it on the webpage at checkout, or the payee is a friend and sends it via instant message or email. 
The payer uses his Lightning wallet to make the invoice payment (e.g. by scanning a QR code). 
In Lightning, "payment" is the analog term for a Bitcoin "transaction".

Along the same lines, in Lightning some users prefer to use "payer" and "payee" to what Bitcoin often refers to as "sender" and "receiver". 
This is merely a matter of convention.
These terms just underline that Lightning is a very specific network, it is a "payment" network. 

==== Selecting Outputs vs Finding a Path

In order to make a payment on the Bitcoin network, a sender needs to consume one or more Unspent Transaction Outputs (UTXOs).
If a user has multiple UTXOs, they need to select which one to send.
For instance, a user making a payment of 1 BTC can use a single output with value 1 BTC, two outputs with value 0.25 BTC and 0.75 BTC, or four outputs with value 0.25 BTC each.

On Lightning, payments do not require inputs to be consumed but rather for the channel balance to be updated.
This is done by finding a path of channels with sufficient capacity from the sender to the receiver.
As many paths may exist, the choice of path to the Lightning Network payer is somewhat analogous to the choice of UTXO to the Bitcoin payer.

==== Change Outputs on Bitcoin vs No Change on Lightning

In order to make a payment on the Bitcoin network, a sender needs to consume one or more Unspent Transaction Outputs (UTXOs).
The entire UTXO needs to be spent, so if a user wishes to spend 0.8 BTC, but only has a 1 BTC UTXO, then they need to send 0.8 BTC to the receiver, and 0.2 BTC back to themselves as change.
This 0.2 BTC creates a new UTXO called a 'change output'.

On Lightning, the UTXO is consumed during the Funding Transaction, which leads to the creation of a channel.
Once the bitcoin is locked within that channel, portions of it can be sent back and forth within the channel, without the need to create any change.
This is because the channel partners simply update the channel balance and only create a new UTXO when the channel is eventually closed using the Bitcoin network.

==== Mining Fees vs Routing Fees

On the Bitcoin network, users pay fees to miners to have their transactions included in a block.
These fees are paid to the miner who mines that particular block.
The amount of the fee is based on the _size_ of the transaction in _bytes_ that the transaction is using in a block, as well as how quickly the user wants that transaction mined.
As miners will typically mine the most profitable transactions first, a user who wants their transaction mined immediately will pay a _higher_ fee-per-byte, while a user who is not in a hurry will pay a _lower_ fee-per-byte.

On the Lightning Network, users pay fees to other users to route payments through their channels.
In order to route a payment, a routing user will have to move the funds in two or more channels they own, as well as transmit the data for the sender's payment.
Typically, the routing user will charge the sender based on the _value_ of the payment, as well as setting their own fees they established to route the payment.
Higher value payments will thus cost more to route, and a market for capacity will exist where different users will charge different fees for routing through their channels.

==== Varying Fees Depending Traffic vs Announced Fees

On the Bitcoin network, miners are profit-seeking and will typically include as many transactions in a block as possible, while staying within the block size limit (actually, a modified form called the block weight limit).
If there are more transactions in the queue (called the mempool) than can fit in a block, they will begin by mining the transactions that pay the highest fees per byte (highest fee per weight).
Thus, if there are many transactions in the queue, users will have to pay a higher fee to be included in the next block, or they will have to wait until there are fewer transactions in the queue.
This naturally leads to the creation of a fee market where users pay based on how urgently they need their transaction included in the next block.

The scarce resource on the Bitcoin network is the space in the blocks. Bitcoin users compete for block space. And the Bitcoin fee market is based on available block space. The scarce resource in the Lightning network is the capacities on the channels and channel connectivity. Lightning users compete for capacity and connectivity. The Lightning fee market is driven by capacity and connectivity.

On the Lightning Network, users are paying fees to the users routing their payments. Routing a payment in economic terms is nothing else than providing and assigning capacity to the payer.
Different routers will charge different fees for routing through their channels.
Naturally, routers who are charging lower fees for the same capacity will be more attractive to route through.
Thus a fee market exists where routers are in competition with each other over the fees they charge to route payments through their channels.
Following general economic principles, the more capacity and connectivity is provided the more competition there will be and as a result the lower the fees will be.

The growth of the Lightning Network might lead to lower Lightning fees, while the growth in the Bitcoin Network likely leads to higher Bitcoin fees.


==== Public Transactions on the Blockchain vs Secret Payments

On the Bitcoin network, every payment is publicly visible on the ledger, i.e. the blockchain.
While the addresses involved are pseudonymous and are not typically tied to identity, they will still be collected and validated by every other user on the network.
Professional companies collect and analyse this data en-masse and sell it to interested parties such as exchanges or governments. 

Lightning Network payments, on the other hand, are completely private.
Typically only the sender and the receiver will be fully aware of the source, destination, and amount of bitcoin transacted in a particular payment.
However, it is not required for the receiver to even know the source of the payment.
As payments are onion-routed, the users who route the payment will only be aware of the amount of the payment, but neither the source nor the destination.
This is because the security model of Lightning only requires users to control the balances in their channels.
They are not required to be aware of the state of the entire network. 

In summary, Bitcoin transactions are broadcasted publicly and stored forever. Lightning payments are executed between a few selected peers and information about is privately stored and only until the channel is closed. 
Creating en-masse analysis tools equivalent to the ones on the Bitcoin network will be impossible on Lightning. 

==== Waiting for Confirmations vs Instant Settlement

On the Bitcoin network, transactions are only 'settled' once they have been included in a block, in which case they are 'confirmed' in that block.
As more blocks are mined on the Bitcoin network thereafter, the transaction acquires more 'confirmations' and is considered more secure.

On the Lightning Network, confirmations only matters for opening and closing channels on-chain.
Once a Funding Transaction has reached a suitable number of confirmations (e.g. 3), the channel partners consider the channel open.
As the bitcoin in the channel is secured by the smart contract that manages that channel, payments settle instantly once received by the receiver.
In practical terms, instant settlement means that payments take on the order of a few seconds to execute.
And as on Bitcoin, Lightning payments are not reversible.
When the channel is closed, a transaction will be made on the Bitcoin network and, only once that transaction is confirmed will the channel be considered closed.

==== Sending Arbitrary Amounts vs Capacity Restrictions

On the Bitcoin network, a user can send any amount of bitcoin that they own to another user, without capacity restrictions.

On the Lightning Network, a user can only send as much bitcoin as currently exists on their side of a particular channel to a channel partner.
For instance, if a user owns one channel with 0.4 BTC on their side, and another channel with 0.2 BTC on their side, then the maximum they can send with one payment is 0.4 BTC.
This is true regardless of how much bitcoin the user currently has in their Bitcoin wallet.

At the time of writing, Atomic Multi-Path Payments (AMPs) are in development which, in the above example, would allow the user to combine both their 0.4 BTC and 0.2 BTC channels to be able to send a maximum of 0.6 BTC with one payment.

In a direct payment where payer and payee are connected via a channel, the limit is stated as above. 
If the payment gets routed, every routing node along the routing path must have at least the amount of funds as indicated in the payment. 
If person A pays person C via person B, the payment follows the route A-B-C. 
Say, person A wants to pay C the amount of 0.4 BTC. 
Then both A as well as B must have 0.4 BTC available in their respective channels A-B and B-C.
The same holds true for longer routes. 
There must be enough liquidity available on the channel for the node that wants to forward the payment. 
This must hold true for every single channel that the payment is routed through.
The lowest capacity of a channel set the upper limit of the full route through this channel. 
Hence, capacity and connectivity are crucial resources in the Lightning network. 

==== Incentives for Large Transaction Value vs. Incentives for Small Transaction Values

The fee structure in Bitcoin is independent of the transaction value. 
A $1 million transaction has the same fee as a $1 transaction on Bitcoin. 
In Lightning the fee is a fixed base fee plus a percentage of the transaction value. 
Hence, in Lightning the payment fee increases with payment value. 
These opposing fee structures create different incentives and lead to different usage in regards to transaction value.
A transaction of enough value will be cheaper on Bitcoin and hence users will prefer Bitcoin for large value transactions.
Similarly, on the other end of the spectrum, users will prefer Lightning for small value transactions.

==== Using the Blockchain as a Ledger vs Using the Blockchain as a Court System

On the Bitcoin Network, every transaction is eventually recorded in a block on the blockchain.
The blockchain thus forms a complete history of every transaction since Bitcoin's creation, and a way to fully audit every bitcoin in existence.
Once a transaction is included in the blockchain it is final.
Thus, no disputes can arise and it is unambiguous how much bitcoin is controlled by a particular address at a particular point in the blockchain.
(The only possible dispute is if the blockchain forks into two or more different blockchains.)

On the Lightning Network, the balance in a channel at a particular time is known only to the two channel partners, and is only made visible to the rest of the network when the channel is closed.
When the channel is closed, the final balance of the channel is submitted to the Bitcoin blockchain, and each partner receives their share of the bitcoin in that channel.
For instance, if the opening balance was 1 BTC paid by Alice, and Alice made a payment of 0.3 BTC to Bob, then the final balance of the channel is 0.7 BTC for Alice and 0.3 BTC for Bob.
If Alice tries to cheat by submitting the opening state of the channel to the Bitcoin blockchain, with 1 BTC for Alice and 0 BTC for Bob, then Bob can retaliate by submitting the true final state of the channel, as well as create a penalty transaction that gives him all bitcoin in the channel.
For the Lightning network, the Bitcoin blockchain acts as a court system.
Like an arbitrer Bitcoin records the initial and final balances of each channel, and approves penalties if one of the parties tries to cheat.

==== Offline vs Online, Asynchronous vs Synchronous

When a Bitcoin user sends funds to a destination address he does not need to know anything about the recipient.
The recipient could be logically speaking "online" (e.g. run a node) or could be "offline" (e.g. does not run a node, does not use any wallet currently). 
The transaction is registered in the blockchain, and at any later point in time the recipient can have a look at it and see that has has received funds in the past. 
In Bitcoin, the recipient can be "offline" and the interaction is asynchronous, sender and receiver do not need to synchronize in any way.

In Lightning, this is different. 
The node that represents the payee must be "online" during the transaction. 
The payee must run a node or have someone that runs a node for him.  
That node must be "online" at the time of the payment.
To be precise, both nodes, the payer's and the payee's must be online at the time of payment.
The payer and payee must cooperate, i.e. in some fashion one could say "synchronize" , during the payment. 
If the payee's node is down the payer cannot make the payment.

==== Satoshis vs. Milli-Satoshis
On Bitcoin the smallest amount is a "satoshi" which cannot be divided any further.
Lightning can be more flexible. 
Lightning nodes can optionally be configured to work with "milli-satoshis". 
So, within Lightning even smaller amounts can be exchanged. 
When settled on-chain, it must be settled in "satoshis".

==== Blockchain Space as Scarcity vs. Channel Capacity as Scarcity
Bitcoin and Lightning have different scarce resources. 
The scarce resource for operating on the Bitcoin protocol is the space in the blockchain. 
The scarce resource for operating on Lightning is the channel capacity, or in other words the liquidity.

=== Commonality of Bitcoin and Lightning

==== Monetary Unit

Both the Bitcoin network and the Lightning network use the same monetary units: bitcoins. 
Lightning payments use the very same bitcoins as Bitcoin transactions.
As an implication, because the monetary unit is the same, also the economic monetary limit is the same: 21 million bitcoins.
From these 21 million bitcoins, some are locked in 2-out-of-2 multisig addresses so that they can enable a payment channel on the Lightning Network.

==== Irrevocability 

Both, Bitcoin transactions and Lightning payments are irrevocable. 
There is no "undo" operation for either one. 
As a user of either one you have to act responsibly.

==== Trustlessness

Just as Bitcoin, Lightning requires the user only to trust mathematics, encryption and that the Lightning code does not have any critical bugs.
Neither Bitcoin nor Lightning require the user to trust a person, a company, an institution or a government.
Since Lightning sits on top of Bitcoin and relies on Bitcoin as its underlying base layer, it is clear that the security model of Lightning reduces to the security of the base blockchain. 
In other words, Lightning can never be more trustless than Bitcoin.

==== Permissionlessness

Both Bitcoin and Lightning can be used by anybody with access to the Internet and to the appropriate software, e.g. node and wallet. 
The user of neither network requires permission from third-party persons, companies, institutions or a government.
The user does not need permission from anybody as long as he has access to Internet and can run his node or wallet.
Governments can only outlaw Bitcoin or Lightning locally in their jurisdiction, but they cannot prevent their global use.

==== Open Source

Both, Bitcoin and Lightning are open source software and are built by a decentralized global community on open source principles.
